#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import fb303_asyncio.fb303.FacebookService
from .ttypes import *
import fb303_asyncio.fb303.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

import thrift
if six.PY3 and not thrift.trollius:
  import asyncio
  from thrift.util.asyncio import call_as_future
else:
  import trollius as asyncio
  from thrift.util.trollius import call_as_future
from thrift.util.Decorators import *

class Iface(fb303_asyncio.fb303.FacebookService.Iface):
  def run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
    """
    pass

  def run_session(self, session=None, command=None, timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
    """
    pass

  def close_session(self, session=None, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
    """
    pass


class ContextIface(fb303_asyncio.fb303.FacebookService.ContextIface):
  def run(self, handler_ctx, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def bulk_run(self, handler_ctx, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def bulk_run_local(self, handler_ctx, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    pass

  def open_session(self, handler_ctx, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
    """
    pass

  def run_session(self, handler_ctx, session=None, command=None, timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
    """
    pass

  def close_session(self, handler_ctx, session=None, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class run_args:
  """
  Attributes:
   - command
   - device
   - timeout
   - open_timeout
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_args')
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 1)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.device != None:
      oprot.writeFieldBegin('device', TType.STRUCT, 2)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.command, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    command=%s' % (value))
    value = pprint.pformat(self.device, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    device=%s' % (value))
    value = pprint.pformat(self.timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timeout=%s' % (value))
    value = pprint.pformat(self.open_timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    open_timeout=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_args)
run_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'command', True, None, 2, ), # 1
  (2, TType.STRUCT, 'device', [Device, Device.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

run_args.thrift_struct_annotations = {
}
run_args.thrift_field_annotations = {
}

def run_args__init__(self, command=None, device=None, timeout=run_args.thrift_spec[3][4], open_timeout=run_args.thrift_spec[4][4], client_ip=run_args.thrift_spec[10][4], client_port=run_args.thrift_spec[11][4],):
  self.command = command
  self.device = device
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port

run_args.__init__ = run_args__init__

class run_result:
  """
  Attributes:
   - success
   - se
   - ude
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommandResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ude = UnsupportedDeviceException()
          self.ude.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    if self.ude != None:
      oprot.writeFieldBegin('ude', TType.STRUCT, 2)
      self.ude.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.se, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    se=%s' % (value))
    value = pprint.pformat(self.ude, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ude=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_result)
run_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [CommandResult, CommandResult.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'ude', [UnsupportedDeviceException, UnsupportedDeviceException.thrift_spec, False], None, 2, ), # 2
)

run_result.thrift_struct_annotations = {
}
run_result.thrift_field_annotations = {
}

def run_result__init__(self, success=None, se=None, ude=None,):
  self.success = success
  self.se = se
  self.ude = ude

run_result.__init__ = run_result__init__

class bulk_run_args:
  """
  Attributes:
   - device_to_commands
   - timeout
   - open_timeout
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.device_to_commands = {}
          (_ktype12, _vtype13, _size11 ) = iprot.readMapBegin() 
          if _size11 >= 0:
            for _i15 in six.moves.range(_size11):
              _key16 = Device()
              _key16.read(iprot)
              _val17 = []
              (_etype21, _size18) = iprot.readListBegin()
              if _size18 >= 0:
                for _i22 in six.moves.range(_size18):
                  _elem23 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val17.append(_elem23)
              else: 
                while iprot.peekList():
                  _elem24 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val17.append(_elem24)
              iprot.readListEnd()
              self.device_to_commands[_key16] = _val17
          else: 
            while iprot.peekMap():
              _key25 = Device()
              _key25.read(iprot)
              _val26 = []
              (_etype30, _size27) = iprot.readListBegin()
              if _size27 >= 0:
                for _i31 in six.moves.range(_size27):
                  _elem32 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val26.append(_elem32)
              else: 
                while iprot.peekList():
                  _elem33 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val26.append(_elem33)
              iprot.readListEnd()
              self.device_to_commands[_key25] = _val26
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_args')
    if self.device_to_commands != None:
      oprot.writeFieldBegin('device_to_commands', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.device_to_commands))
      for kiter34,viter35 in self.device_to_commands.items():
        kiter34.write(oprot)
        oprot.writeListBegin(TType.STRING, len(viter35))
        for iter36 in viter35:
          oprot.writeString(iter36.encode('utf-8')) if UTF8STRINGS and not isinstance(iter36, bytes) else oprot.writeString(iter36)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.device_to_commands, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    device_to_commands=%s' % (value))
    value = pprint.pformat(self.timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timeout=%s' % (value))
    value = pprint.pformat(self.open_timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    open_timeout=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_args)
bulk_run_args.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'device_to_commands', (TType.STRUCT,[Device, Device.thrift_spec, False],TType.LIST,(TType.STRING,True)), None, 2, ), # 1
  None, # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

bulk_run_args.thrift_struct_annotations = {
}
bulk_run_args.thrift_field_annotations = {
}

def bulk_run_args__init__(self, device_to_commands=None, timeout=bulk_run_args.thrift_spec[3][4], open_timeout=bulk_run_args.thrift_spec[4][4], client_ip=bulk_run_args.thrift_spec[10][4], client_port=bulk_run_args.thrift_spec[11][4],):
  self.device_to_commands = device_to_commands
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port

bulk_run_args.__init__ = bulk_run_args__init__

class bulk_run_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in six.moves.range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in six.moves.range(_size44):
                  _elem49 = CommandResult()
                  _elem49.read(iprot)
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = CommandResult()
                  _elem50.read(iprot)
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.success[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in six.moves.range(_size53):
                  _elem58 = CommandResult()
                  _elem58.read(iprot)
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = CommandResult()
                  _elem59.read(iprot)
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.success[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter60,viter61 in self.success.items():
        oprot.writeString(kiter60.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter60, bytes) else oprot.writeString(kiter60)
        oprot.writeListBegin(TType.STRUCT, len(viter61))
        for iter62 in viter61:
          iter62.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_result)
bulk_run_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.LIST,(TType.STRUCT,[CommandResult, CommandResult.thrift_spec, False])), None, 2, ), # 0
)

bulk_run_result.thrift_struct_annotations = {
}
bulk_run_result.thrift_field_annotations = {
}

def bulk_run_result__init__(self, success=None,):
  self.success = success

bulk_run_result.__init__ = bulk_run_result__init__

class bulk_run_local_args:
  """
  Attributes:
   - device_to_commands
   - timeout
   - open_timeout
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.device_to_commands = {}
          (_ktype64, _vtype65, _size63 ) = iprot.readMapBegin() 
          if _size63 >= 0:
            for _i67 in six.moves.range(_size63):
              _key68 = Device()
              _key68.read(iprot)
              _val69 = []
              (_etype73, _size70) = iprot.readListBegin()
              if _size70 >= 0:
                for _i74 in six.moves.range(_size70):
                  _elem75 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val69.append(_elem75)
              else: 
                while iprot.peekList():
                  _elem76 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val69.append(_elem76)
              iprot.readListEnd()
              self.device_to_commands[_key68] = _val69
          else: 
            while iprot.peekMap():
              _key77 = Device()
              _key77.read(iprot)
              _val78 = []
              (_etype82, _size79) = iprot.readListBegin()
              if _size79 >= 0:
                for _i83 in six.moves.range(_size79):
                  _elem84 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val78.append(_elem84)
              else: 
                while iprot.peekList():
                  _elem85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val78.append(_elem85)
              iprot.readListEnd()
              self.device_to_commands[_key77] = _val78
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_local_args')
    if self.device_to_commands != None:
      oprot.writeFieldBegin('device_to_commands', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.device_to_commands))
      for kiter86,viter87 in self.device_to_commands.items():
        kiter86.write(oprot)
        oprot.writeListBegin(TType.STRING, len(viter87))
        for iter88 in viter87:
          oprot.writeString(iter88.encode('utf-8')) if UTF8STRINGS and not isinstance(iter88, bytes) else oprot.writeString(iter88)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.device_to_commands, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    device_to_commands=%s' % (value))
    value = pprint.pformat(self.timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timeout=%s' % (value))
    value = pprint.pformat(self.open_timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    open_timeout=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_local_args)
bulk_run_local_args.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'device_to_commands', (TType.STRUCT,[Device, Device.thrift_spec, False],TType.LIST,(TType.STRING,True)), None, 2, ), # 1
  None, # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

bulk_run_local_args.thrift_struct_annotations = {
}
bulk_run_local_args.thrift_field_annotations = {
}

def bulk_run_local_args__init__(self, device_to_commands=None, timeout=bulk_run_local_args.thrift_spec[3][4], open_timeout=bulk_run_local_args.thrift_spec[4][4], client_ip=bulk_run_local_args.thrift_spec[10][4], client_port=bulk_run_local_args.thrift_spec[11][4],):
  self.device_to_commands = device_to_commands
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port

bulk_run_local_args.__init__ = bulk_run_local_args__init__

class bulk_run_local_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype90, _vtype91, _size89 ) = iprot.readMapBegin() 
          if _size89 >= 0:
            for _i93 in six.moves.range(_size89):
              _key94 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val95 = []
              (_etype99, _size96) = iprot.readListBegin()
              if _size96 >= 0:
                for _i100 in six.moves.range(_size96):
                  _elem101 = CommandResult()
                  _elem101.read(iprot)
                  _val95.append(_elem101)
              else: 
                while iprot.peekList():
                  _elem102 = CommandResult()
                  _elem102.read(iprot)
                  _val95.append(_elem102)
              iprot.readListEnd()
              self.success[_key94] = _val95
          else: 
            while iprot.peekMap():
              _key103 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val104 = []
              (_etype108, _size105) = iprot.readListBegin()
              if _size105 >= 0:
                for _i109 in six.moves.range(_size105):
                  _elem110 = CommandResult()
                  _elem110.read(iprot)
                  _val104.append(_elem110)
              else: 
                while iprot.peekList():
                  _elem111 = CommandResult()
                  _elem111.read(iprot)
                  _val104.append(_elem111)
              iprot.readListEnd()
              self.success[_key103] = _val104
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_local_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter112,viter113 in self.success.items():
        oprot.writeString(kiter112.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter112, bytes) else oprot.writeString(kiter112)
        oprot.writeListBegin(TType.STRUCT, len(viter113))
        for iter114 in viter113:
          iter114.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_local_result)
bulk_run_local_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.LIST,(TType.STRUCT,[CommandResult, CommandResult.thrift_spec, False])), None, 2, ), # 0
)

bulk_run_local_result.thrift_struct_annotations = {
}
bulk_run_local_result.thrift_field_annotations = {
}

def bulk_run_local_result__init__(self, success=None,):
  self.success = success

bulk_run_local_result.__init__ = bulk_run_local_result__init__

class open_session_args:
  """
  Attributes:
   - device
   - open_timeout
   - idle_timeout
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.idle_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_session_args')
    if self.device != None:
      oprot.writeFieldBegin('device', TType.STRUCT, 1)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 2)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.idle_timeout != None:
      oprot.writeFieldBegin('idle_timeout', TType.I32, 3)
      oprot.writeI32(self.idle_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.device, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    device=%s' % (value))
    value = pprint.pformat(self.open_timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    open_timeout=%s' % (value))
    value = pprint.pformat(self.idle_timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    idle_timeout=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_session_args)
open_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'device', [Device, Device.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'open_timeout', None, 60, 2, ), # 2
  (3, TType.I32, 'idle_timeout', None, 300, 2, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

open_session_args.thrift_struct_annotations = {
}
open_session_args.thrift_field_annotations = {
}

def open_session_args__init__(self, device=None, open_timeout=open_session_args.thrift_spec[2][4], idle_timeout=open_session_args.thrift_spec[3][4], client_ip=open_session_args.thrift_spec[10][4], client_port=open_session_args.thrift_spec[11][4],):
  self.device = device
  self.open_timeout = open_timeout
  self.idle_timeout = idle_timeout
  self.client_ip = client_ip
  self.client_port = client_port

open_session_args.__init__ = open_session_args__init__

class open_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Session()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.se, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    se=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_session_result)
open_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [Session, Session.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

open_session_result.thrift_struct_annotations = {
}
open_session_result.thrift_field_annotations = {
}

def open_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

open_session_result.__init__ = open_session_result__init__

class run_session_args:
  """
  Attributes:
   - session
   - command
   - timeout
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 2)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.session, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    session=%s' % (value))
    value = pprint.pformat(self.command, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    command=%s' % (value))
    value = pprint.pformat(self.timeout, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timeout=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_session_args)
run_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'command', True, None, 2, ), # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

run_session_args.thrift_struct_annotations = {
}
run_session_args.thrift_field_annotations = {
}

def run_session_args__init__(self, session=None, command=None, timeout=run_session_args.thrift_spec[3][4], client_ip=run_session_args.thrift_spec[10][4], client_port=run_session_args.thrift_spec[11][4],):
  self.session = session
  self.command = command
  self.timeout = timeout
  self.client_ip = client_ip
  self.client_port = client_port

run_session_args.__init__ = run_session_args__init__

class run_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommandResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.se, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    se=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_session_result)
run_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [CommandResult, CommandResult.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

run_session_result.thrift_struct_annotations = {
}
run_session_result.thrift_field_annotations = {
}

def run_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

run_session_result.__init__ = run_session_result__init__

class close_session_args:
  """
  Attributes:
   - session
   - client_ip
   - client_port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.session, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    session=%s' % (value))
    value = pprint.pformat(self.client_ip, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_ip=%s' % (value))
    value = pprint.pformat(self.client_port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    client_port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_session_args)
close_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
)

close_session_args.thrift_struct_annotations = {
}
close_session_args.thrift_field_annotations = {
}

def close_session_args__init__(self, session=None, client_ip=close_session_args.thrift_spec[10][4], client_port=close_session_args.thrift_spec[11][4],):
  self.session = session
  self.client_ip = client_ip
  self.client_port = client_port

close_session_args.__init__ = close_session_args__init__

class close_session_result:
  """
  Attributes:
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_session_result')
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.se, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    se=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_session_result)
close_session_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

close_session_result.thrift_struct_annotations = {
}
close_session_result.thrift_field_annotations = {
}

def close_session_result__init__(self, se=None,):
  self.se = se

close_session_result.__init__ = close_session_result__init__

class Client(fb303_asyncio.fb303.FacebookService.Client, Iface):
  def __init__(self, oprot, loop=None):
    fb303_asyncio.fb303.FacebookService.Client.__init__(self, oprot, loop)

  def run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_run(command, device, timeout, open_timeout, client_ip, client_port)
    return fut

  def send_run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('run', TMessageType.CALL, self._seqid)
    args = run_args()
    args.command = command
    args.device = device
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = run_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    if result.ude != None:
      fut.set_exception(result.ude)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result"))
    return

  def bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_bulk_run(device_to_commands, timeout, open_timeout, client_ip, client_port)
    return fut

  def send_bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('bulk_run', TMessageType.CALL, self._seqid)
    args = bulk_run_args()
    args.device_to_commands = device_to_commands
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bulk_run(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = bulk_run_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "bulk_run failed: unknown result"))
    return

  def bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_bulk_run_local(device_to_commands, timeout, open_timeout, client_ip, client_port)
    return fut

  def send_bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('bulk_run_local', TMessageType.CALL, self._seqid)
    args = bulk_run_local_args()
    args.device_to_commands = device_to_commands
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bulk_run_local(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = bulk_run_local_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "bulk_run_local failed: unknown result"))
    return

  def open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_open_session(device, open_timeout, idle_timeout, client_ip, client_port)
    return fut

  def send_open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('open_session', TMessageType.CALL, self._seqid)
    args = open_session_args()
    args.device = device
    args.open_timeout = open_timeout
    args.idle_timeout = idle_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = open_session_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "open_session failed: unknown result"))
    return

  def run_session(self, session=None, command=None, timeout=300, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_run_session(session, command, timeout, client_ip, client_port)
    return fut

  def send_run_session(self, session=None, command=None, timeout=300, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('run_session', TMessageType.CALL, self._seqid)
    args = run_session_args()
    args.session = session
    args.command = command
    args.timeout = timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = run_session_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "run_session failed: unknown result"))
    return

  def close_session(self, session=None, client_ip="", client_port=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_close_session(session, client_ip, client_port)
    return fut

  def send_close_session(self, session=None, client_ip="", client_port=""):
    self._oprot.writeMessageBegin('close_session', TMessageType.CALL, self._seqid)
    args = close_session_args()
    args.session = session
    args.client_ip = client_ip
    args.client_port = client_port
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_close_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = close_session_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_result(None)
    return


class Processor(fb303_asyncio.fb303.FacebookService.Processor, Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler, loop=None):
    fb303_asyncio.fb303.FacebookService.Processor.__init__(self, handler, loop)
    self._processMap["run"] = Processor.process_run
    self._processMap["bulk_run"] = Processor.process_bulk_run
    self._processMap["bulk_run_local"] = Processor.process_bulk_run_local
    self._processMap["open_session"] = Processor.process_open_session
    self._processMap["run_session"] = Processor.process_run_session
    self._processMap["close_session"] = Processor.process_close_session

  def onewayMethods(self):
    l = []
    l.extend(fb303_asyncio.fb303.FacebookService.Processor.onewayMethods(self))
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(run_args, oneway=False, asyncio=True)
  def process_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_result()
    if should_run_on_thread(self._handler.run):
      fut = self._loop.run_in_executor(None, self._handler.run, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.run, self._loop, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException, 'ude': UnsupportedDeviceException}, f))
    return fut

  @process_method(bulk_run_args, oneway=False, asyncio=True)
  def process_bulk_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_result()
    if should_run_on_thread(self._handler.bulk_run):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.bulk_run, self._loop, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(bulk_run_local_args, oneway=False, asyncio=True)
  def process_bulk_run_local(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_local_result()
    if should_run_on_thread(self._handler.bulk_run_local):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run_local, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.bulk_run_local, self._loop, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(open_session_args, oneway=False, asyncio=True)
  def process_open_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_session_result()
    if should_run_on_thread(self._handler.open_session):
      fut = self._loop.run_in_executor(None, self._handler.open_session, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.open_session, self._loop, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_session_args, oneway=False, asyncio=True)
  def process_run_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_session_result()
    if should_run_on_thread(self._handler.run_session):
      fut = self._loop.run_in_executor(None, self._handler.run_session, args.session, args.command, args.timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.run_session, self._loop, args.session, args.command, args.timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_session_args, oneway=False, asyncio=True)
  def process_close_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_session_result()
    if should_run_on_thread(self._handler.close_session):
      fut = self._loop.run_in_executor(None, self._handler.close_session, args.session, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.close_session, self._loop, args.session, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

Iface._processor_type = Processor

class ContextProcessor(fb303_asyncio.fb303.FacebookService.ContextProcessor, ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler, loop=None):
    fb303_asyncio.fb303.FacebookService.ContextProcessor.__init__(self, handler, loop)
    self._processMap["run"] = ContextProcessor.process_run
    self._processMap["bulk_run"] = ContextProcessor.process_bulk_run
    self._processMap["bulk_run_local"] = ContextProcessor.process_bulk_run_local
    self._processMap["open_session"] = ContextProcessor.process_open_session
    self._processMap["run_session"] = ContextProcessor.process_run_session
    self._processMap["close_session"] = ContextProcessor.process_close_session

  def onewayMethods(self):
    l = []
    l.extend(fb303_asyncio.fb303.FacebookService.ContextProcessor.onewayMethods(self))
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(run_args, oneway=False, asyncio=True)
  def process_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_result()
    if should_run_on_thread(self._handler.run):
      fut = self._loop.run_in_executor(None, self._handler.run, handler_ctx, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.run, self._loop, handler_ctx, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException, 'ude': UnsupportedDeviceException}, f))
    return fut

  @process_method(bulk_run_args, oneway=False, asyncio=True)
  def process_bulk_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_result()
    if should_run_on_thread(self._handler.bulk_run):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.bulk_run, self._loop, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(bulk_run_local_args, oneway=False, asyncio=True)
  def process_bulk_run_local(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_local_result()
    if should_run_on_thread(self._handler.bulk_run_local):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run_local, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.bulk_run_local, self._loop, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(open_session_args, oneway=False, asyncio=True)
  def process_open_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_session_result()
    if should_run_on_thread(self._handler.open_session):
      fut = self._loop.run_in_executor(None, self._handler.open_session, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.open_session, self._loop, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_session_args, oneway=False, asyncio=True)
  def process_run_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_session_result()
    if should_run_on_thread(self._handler.run_session):
      fut = self._loop.run_in_executor(None, self._handler.run_session, handler_ctx, args.session, args.command, args.timeout, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.run_session, self._loop, handler_ctx, args.session, args.command, args.timeout, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_session_args, oneway=False, asyncio=True)
  def process_close_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_session_result()
    if should_run_on_thread(self._handler.close_session):
      fut = self._loop.run_in_executor(None, self._handler.close_session, handler_ctx, args.session, args.client_ip, args.client_port)
    else:
      fut = call_as_future(self._handler.close_session, self._loop, handler_ctx, args.session, args.client_ip, args.client_port)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

