#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import fb303_asyncio.fb303.FacebookService
from .ttypes import *
import fb303_asyncio.fb303.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

import thrift
if six.PY3 and not thrift.trollius:
  import asyncio
  from thrift.util.asyncio import call_as_future
else:
  import trollius as asyncio
  from thrift.util.trollius import call_as_future
from thrift.util.Decorators import *

class Iface(fb303_asyncio.fb303.FacebookService.Iface):
  def run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def run_session(self, session=None, command=None, timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def close_session(self, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    pass

  def open_raw_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def run_raw_session(self, session=None, command=None, timeout=300, prompt_regex=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - prompt_regex
     - client_ip
     - client_port
     - uuid
    """
    pass

  def close_raw_session(self, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    pass


class ContextIface(fb303_asyncio.fb303.FacebookService.ContextIface):
  def run(self, handler_ctx, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def bulk_run(self, handler_ctx, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def bulk_run_local(self, handler_ctx, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def open_session(self, handler_ctx, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def run_session(self, handler_ctx, session=None, command=None, timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def close_session(self, handler_ctx, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    pass

  def open_raw_session(self, handler_ctx, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    pass

  def run_raw_session(self, handler_ctx, session=None, command=None, timeout=300, prompt_regex=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - prompt_regex
     - client_ip
     - client_port
     - uuid
    """
    pass

  def close_raw_session(self, handler_ctx, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class run_args:
  """
  Attributes:
   - command
   - device
   - timeout
   - open_timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_args')
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 1)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.device != None:
      oprot.writeFieldBegin('device', TType.STRUCT, 2)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.command is not None:
      value = pprint.pformat(self.command, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    command=%s' % (value))
    if self.device is not None:
      value = pprint.pformat(self.device, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    device=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.open_timeout is not None:
      value = pprint.pformat(self.open_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    open_timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_args)
run_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'command', True, None, 2, ), # 1
  (2, TType.STRUCT, 'device', [Device, Device.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

run_args.thrift_struct_annotations = {
}
run_args.thrift_field_annotations = {
}

def run_args__init__(self, command=None, device=None, timeout=run_args.thrift_spec[3][4], open_timeout=run_args.thrift_spec[4][4], client_ip=run_args.thrift_spec[10][4], client_port=run_args.thrift_spec[11][4], uuid=run_args.thrift_spec[12][4],):
  self.command = command
  self.device = device
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

run_args.__init__ = run_args__init__

def run_args__setstate__(self, state):
  state.setdefault('command', None)
  state.setdefault('device', None)
  state.setdefault('timeout', 300)
  state.setdefault('open_timeout', 30)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

run_args.__getstate__ = lambda self: self.__dict__.copy()
run_args.__setstate__ = run_args__setstate__

class run_result:
  """
  Attributes:
   - success
   - se
   - ude
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommandResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ude = UnsupportedDeviceException()
          self.ude.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    if self.ude != None:
      oprot.writeFieldBegin('ude', TType.STRUCT, 2)
      self.ude.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    if self.ude is not None:
      value = pprint.pformat(self.ude, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ude=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_result)
run_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [CommandResult, CommandResult.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'ude', [UnsupportedDeviceException, UnsupportedDeviceException.thrift_spec, False], None, 2, ), # 2
)

run_result.thrift_struct_annotations = {
}
run_result.thrift_field_annotations = {
}

def run_result__init__(self, success=None, se=None, ude=None,):
  self.success = success
  self.se = se
  self.ude = ude

run_result.__init__ = run_result__init__

def run_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('se', None)
  state.setdefault('ude', None)
  self.__dict__ = state

run_result.__getstate__ = lambda self: self.__dict__.copy()
run_result.__setstate__ = run_result__setstate__

class bulk_run_args:
  """
  Attributes:
   - device_to_commands
   - timeout
   - open_timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.device_to_commands = {}
          (_ktype23, _vtype24, _size22 ) = iprot.readMapBegin() 
          if _size22 >= 0:
            for _i26 in six.moves.range(_size22):
              _key27 = Device()
              _key27.read(iprot)
              _val28 = []
              (_etype32, _size29) = iprot.readListBegin()
              if _size29 >= 0:
                for _i33 in six.moves.range(_size29):
                  _elem34 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val28.append(_elem34)
              else: 
                while iprot.peekList():
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val28.append(_elem35)
              iprot.readListEnd()
              self.device_to_commands[_key27] = _val28
          else: 
            while iprot.peekMap():
              _key36 = Device()
              _key36.read(iprot)
              _val37 = []
              (_etype41, _size38) = iprot.readListBegin()
              if _size38 >= 0:
                for _i42 in six.moves.range(_size38):
                  _elem43 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37.append(_elem43)
              else: 
                while iprot.peekList():
                  _elem44 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37.append(_elem44)
              iprot.readListEnd()
              self.device_to_commands[_key36] = _val37
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_args')
    if self.device_to_commands != None:
      oprot.writeFieldBegin('device_to_commands', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.device_to_commands))
      for kiter45,viter46 in self.device_to_commands.items():
        kiter45.write(oprot)
        oprot.writeListBegin(TType.STRING, len(viter46))
        for iter47 in viter46:
          oprot.writeString(iter47.encode('utf-8')) if UTF8STRINGS and not isinstance(iter47, bytes) else oprot.writeString(iter47)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.device_to_commands is not None:
      value = pprint.pformat(self.device_to_commands, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    device_to_commands=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.open_timeout is not None:
      value = pprint.pformat(self.open_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    open_timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_args)
bulk_run_args.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'device_to_commands', (TType.STRUCT,[Device, Device.thrift_spec, False],TType.LIST,(TType.STRING,True)), None, 2, ), # 1
  None, # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

bulk_run_args.thrift_struct_annotations = {
}
bulk_run_args.thrift_field_annotations = {
}

def bulk_run_args__init__(self, device_to_commands=None, timeout=bulk_run_args.thrift_spec[3][4], open_timeout=bulk_run_args.thrift_spec[4][4], client_ip=bulk_run_args.thrift_spec[10][4], client_port=bulk_run_args.thrift_spec[11][4], uuid=bulk_run_args.thrift_spec[12][4],):
  self.device_to_commands = device_to_commands
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

bulk_run_args.__init__ = bulk_run_args__init__

def bulk_run_args__setstate__(self, state):
  state.setdefault('device_to_commands', None)
  state.setdefault('timeout', 300)
  state.setdefault('open_timeout', 30)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

bulk_run_args.__getstate__ = lambda self: self.__dict__.copy()
bulk_run_args.__setstate__ = bulk_run_args__setstate__

class bulk_run_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in six.moves.range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = []
              (_etype58, _size55) = iprot.readListBegin()
              if _size55 >= 0:
                for _i59 in six.moves.range(_size55):
                  _elem60 = CommandResult()
                  _elem60.read(iprot)
                  _val54.append(_elem60)
              else: 
                while iprot.peekList():
                  _elem61 = CommandResult()
                  _elem61.read(iprot)
                  _val54.append(_elem61)
              iprot.readListEnd()
              self.success[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key62 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val63 = []
              (_etype67, _size64) = iprot.readListBegin()
              if _size64 >= 0:
                for _i68 in six.moves.range(_size64):
                  _elem69 = CommandResult()
                  _elem69.read(iprot)
                  _val63.append(_elem69)
              else: 
                while iprot.peekList():
                  _elem70 = CommandResult()
                  _elem70.read(iprot)
                  _val63.append(_elem70)
              iprot.readListEnd()
              self.success[_key62] = _val63
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter71,viter72 in self.success.items():
        oprot.writeString(kiter71.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter71, bytes) else oprot.writeString(kiter71)
        oprot.writeListBegin(TType.STRUCT, len(viter72))
        for iter73 in viter72:
          iter73.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_result)
bulk_run_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.LIST,(TType.STRUCT,[CommandResult, CommandResult.thrift_spec, False])), None, 2, ), # 0
)

bulk_run_result.thrift_struct_annotations = {
}
bulk_run_result.thrift_field_annotations = {
}

def bulk_run_result__init__(self, success=None,):
  self.success = success

bulk_run_result.__init__ = bulk_run_result__init__

def bulk_run_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

bulk_run_result.__getstate__ = lambda self: self.__dict__.copy()
bulk_run_result.__setstate__ = bulk_run_result__setstate__

class bulk_run_local_args:
  """
  Attributes:
   - device_to_commands
   - timeout
   - open_timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.device_to_commands = {}
          (_ktype75, _vtype76, _size74 ) = iprot.readMapBegin() 
          if _size74 >= 0:
            for _i78 in six.moves.range(_size74):
              _key79 = Device()
              _key79.read(iprot)
              _val80 = []
              (_etype84, _size81) = iprot.readListBegin()
              if _size81 >= 0:
                for _i85 in six.moves.range(_size81):
                  _elem86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val80.append(_elem86)
              else: 
                while iprot.peekList():
                  _elem87 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val80.append(_elem87)
              iprot.readListEnd()
              self.device_to_commands[_key79] = _val80
          else: 
            while iprot.peekMap():
              _key88 = Device()
              _key88.read(iprot)
              _val89 = []
              (_etype93, _size90) = iprot.readListBegin()
              if _size90 >= 0:
                for _i94 in six.moves.range(_size90):
                  _elem95 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val89.append(_elem95)
              else: 
                while iprot.peekList():
                  _elem96 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val89.append(_elem96)
              iprot.readListEnd()
              self.device_to_commands[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_local_args')
    if self.device_to_commands != None:
      oprot.writeFieldBegin('device_to_commands', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.device_to_commands))
      for kiter97,viter98 in self.device_to_commands.items():
        kiter97.write(oprot)
        oprot.writeListBegin(TType.STRING, len(viter98))
        for iter99 in viter98:
          oprot.writeString(iter99.encode('utf-8')) if UTF8STRINGS and not isinstance(iter99, bytes) else oprot.writeString(iter99)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 4)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.device_to_commands is not None:
      value = pprint.pformat(self.device_to_commands, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    device_to_commands=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.open_timeout is not None:
      value = pprint.pformat(self.open_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    open_timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_local_args)
bulk_run_local_args.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'device_to_commands', (TType.STRUCT,[Device, Device.thrift_spec, False],TType.LIST,(TType.STRING,True)), None, 2, ), # 1
  None, # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.I32, 'open_timeout', None, 30, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

bulk_run_local_args.thrift_struct_annotations = {
}
bulk_run_local_args.thrift_field_annotations = {
}

def bulk_run_local_args__init__(self, device_to_commands=None, timeout=bulk_run_local_args.thrift_spec[3][4], open_timeout=bulk_run_local_args.thrift_spec[4][4], client_ip=bulk_run_local_args.thrift_spec[10][4], client_port=bulk_run_local_args.thrift_spec[11][4], uuid=bulk_run_local_args.thrift_spec[12][4],):
  self.device_to_commands = device_to_commands
  self.timeout = timeout
  self.open_timeout = open_timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

bulk_run_local_args.__init__ = bulk_run_local_args__init__

def bulk_run_local_args__setstate__(self, state):
  state.setdefault('device_to_commands', None)
  state.setdefault('timeout', 300)
  state.setdefault('open_timeout', 30)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

bulk_run_local_args.__getstate__ = lambda self: self.__dict__.copy()
bulk_run_local_args.__setstate__ = bulk_run_local_args__setstate__

class bulk_run_local_result:
  """
  Attributes:
   - success
   - ioe
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
          if _size100 >= 0:
            for _i104 in six.moves.range(_size100):
              _key105 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val106 = []
              (_etype110, _size107) = iprot.readListBegin()
              if _size107 >= 0:
                for _i111 in six.moves.range(_size107):
                  _elem112 = CommandResult()
                  _elem112.read(iprot)
                  _val106.append(_elem112)
              else: 
                while iprot.peekList():
                  _elem113 = CommandResult()
                  _elem113.read(iprot)
                  _val106.append(_elem113)
              iprot.readListEnd()
              self.success[_key105] = _val106
          else: 
            while iprot.peekMap():
              _key114 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val115 = []
              (_etype119, _size116) = iprot.readListBegin()
              if _size116 >= 0:
                for _i120 in six.moves.range(_size116):
                  _elem121 = CommandResult()
                  _elem121.read(iprot)
                  _val115.append(_elem121)
              else: 
                while iprot.peekList():
                  _elem122 = CommandResult()
                  _elem122.read(iprot)
                  _val115.append(_elem122)
              iprot.readListEnd()
              self.success[_key114] = _val115
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ioe = InstanceOverloaded()
          self.ioe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('bulk_run_local_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
      for kiter123,viter124 in self.success.items():
        oprot.writeString(kiter123.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter123, bytes) else oprot.writeString(kiter123)
        oprot.writeListBegin(TType.STRUCT, len(viter124))
        for iter125 in viter124:
          iter125.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ioe != None:
      oprot.writeFieldBegin('ioe', TType.STRUCT, 1)
      self.ioe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.ioe is not None:
      value = pprint.pformat(self.ioe, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ioe=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(bulk_run_local_result)
bulk_run_local_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.LIST,(TType.STRUCT,[CommandResult, CommandResult.thrift_spec, False])), None, 2, ), # 0
  (1, TType.STRUCT, 'ioe', [InstanceOverloaded, InstanceOverloaded.thrift_spec, False], None, 2, ), # 1
)

bulk_run_local_result.thrift_struct_annotations = {
}
bulk_run_local_result.thrift_field_annotations = {
}

def bulk_run_local_result__init__(self, success=None, ioe=None,):
  self.success = success
  self.ioe = ioe

bulk_run_local_result.__init__ = bulk_run_local_result__init__

def bulk_run_local_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('ioe', None)
  self.__dict__ = state

bulk_run_local_result.__getstate__ = lambda self: self.__dict__.copy()
bulk_run_local_result.__setstate__ = bulk_run_local_result__setstate__

class open_session_args:
  """
  Attributes:
   - device
   - open_timeout
   - idle_timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.idle_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_session_args')
    if self.device != None:
      oprot.writeFieldBegin('device', TType.STRUCT, 1)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 2)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.idle_timeout != None:
      oprot.writeFieldBegin('idle_timeout', TType.I32, 3)
      oprot.writeI32(self.idle_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.device is not None:
      value = pprint.pformat(self.device, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    device=%s' % (value))
    if self.open_timeout is not None:
      value = pprint.pformat(self.open_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    open_timeout=%s' % (value))
    if self.idle_timeout is not None:
      value = pprint.pformat(self.idle_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    idle_timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_session_args)
open_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'device', [Device, Device.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'open_timeout', None, 60, 2, ), # 2
  (3, TType.I32, 'idle_timeout', None, 300, 2, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

open_session_args.thrift_struct_annotations = {
}
open_session_args.thrift_field_annotations = {
}

def open_session_args__init__(self, device=None, open_timeout=open_session_args.thrift_spec[2][4], idle_timeout=open_session_args.thrift_spec[3][4], client_ip=open_session_args.thrift_spec[10][4], client_port=open_session_args.thrift_spec[11][4], uuid=open_session_args.thrift_spec[12][4],):
  self.device = device
  self.open_timeout = open_timeout
  self.idle_timeout = idle_timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

open_session_args.__init__ = open_session_args__init__

def open_session_args__setstate__(self, state):
  state.setdefault('device', None)
  state.setdefault('open_timeout', 60)
  state.setdefault('idle_timeout', 300)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

open_session_args.__getstate__ = lambda self: self.__dict__.copy()
open_session_args.__setstate__ = open_session_args__setstate__

class open_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Session()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_session_result)
open_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [Session, Session.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

open_session_result.thrift_struct_annotations = {
}
open_session_result.thrift_field_annotations = {
}

def open_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

open_session_result.__init__ = open_session_result__init__

def open_session_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('se', None)
  self.__dict__ = state

open_session_result.__getstate__ = lambda self: self.__dict__.copy()
open_session_result.__setstate__ = open_session_result__setstate__

class run_session_args:
  """
  Attributes:
   - session
   - command
   - timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 2)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    if self.command is not None:
      value = pprint.pformat(self.command, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    command=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_session_args)
run_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'command', True, None, 2, ), # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

run_session_args.thrift_struct_annotations = {
}
run_session_args.thrift_field_annotations = {
}

def run_session_args__init__(self, session=None, command=None, timeout=run_session_args.thrift_spec[3][4], client_ip=run_session_args.thrift_spec[10][4], client_port=run_session_args.thrift_spec[11][4], uuid=run_session_args.thrift_spec[12][4],):
  self.session = session
  self.command = command
  self.timeout = timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

run_session_args.__init__ = run_session_args__init__

def run_session_args__setstate__(self, state):
  state.setdefault('session', None)
  state.setdefault('command', None)
  state.setdefault('timeout', 300)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

run_session_args.__getstate__ = lambda self: self.__dict__.copy()
run_session_args.__setstate__ = run_session_args__setstate__

class run_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommandResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_session_result)
run_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [CommandResult, CommandResult.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

run_session_result.thrift_struct_annotations = {
}
run_session_result.thrift_field_annotations = {
}

def run_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

run_session_result.__init__ = run_session_result__init__

def run_session_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('se', None)
  self.__dict__ = state

run_session_result.__getstate__ = lambda self: self.__dict__.copy()
run_session_result.__setstate__ = run_session_result__setstate__

class close_session_args:
  """
  Attributes:
   - session
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_session_args)
close_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

close_session_args.thrift_struct_annotations = {
}
close_session_args.thrift_field_annotations = {
}

def close_session_args__init__(self, session=None, client_ip=close_session_args.thrift_spec[10][4], client_port=close_session_args.thrift_spec[11][4], uuid=close_session_args.thrift_spec[12][4],):
  self.session = session
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

close_session_args.__init__ = close_session_args__init__

def close_session_args__setstate__(self, state):
  state.setdefault('session', None)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

close_session_args.__getstate__ = lambda self: self.__dict__.copy()
close_session_args.__setstate__ = close_session_args__setstate__

class close_session_result:
  """
  Attributes:
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_session_result')
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_session_result)
close_session_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

close_session_result.thrift_struct_annotations = {
}
close_session_result.thrift_field_annotations = {
}

def close_session_result__init__(self, se=None,):
  self.se = se

close_session_result.__init__ = close_session_result__init__

def close_session_result__setstate__(self, state):
  state.setdefault('se', None)
  self.__dict__ = state

close_session_result.__getstate__ = lambda self: self.__dict__.copy()
close_session_result.__setstate__ = close_session_result__setstate__

class open_raw_session_args:
  """
  Attributes:
   - device
   - open_timeout
   - idle_timeout
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.device = Device()
          self.device.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.open_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.idle_timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_raw_session_args')
    if self.device != None:
      oprot.writeFieldBegin('device', TType.STRUCT, 1)
      self.device.write(oprot)
      oprot.writeFieldEnd()
    if self.open_timeout != None:
      oprot.writeFieldBegin('open_timeout', TType.I32, 2)
      oprot.writeI32(self.open_timeout)
      oprot.writeFieldEnd()
    if self.idle_timeout != None:
      oprot.writeFieldBegin('idle_timeout', TType.I32, 3)
      oprot.writeI32(self.idle_timeout)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.device is not None:
      value = pprint.pformat(self.device, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    device=%s' % (value))
    if self.open_timeout is not None:
      value = pprint.pformat(self.open_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    open_timeout=%s' % (value))
    if self.idle_timeout is not None:
      value = pprint.pformat(self.idle_timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    idle_timeout=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_raw_session_args)
open_raw_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'device', [Device, Device.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'open_timeout', None, 60, 2, ), # 2
  (3, TType.I32, 'idle_timeout', None, 300, 2, ), # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

open_raw_session_args.thrift_struct_annotations = {
}
open_raw_session_args.thrift_field_annotations = {
}

def open_raw_session_args__init__(self, device=None, open_timeout=open_raw_session_args.thrift_spec[2][4], idle_timeout=open_raw_session_args.thrift_spec[3][4], client_ip=open_raw_session_args.thrift_spec[10][4], client_port=open_raw_session_args.thrift_spec[11][4], uuid=open_raw_session_args.thrift_spec[12][4],):
  self.device = device
  self.open_timeout = open_timeout
  self.idle_timeout = idle_timeout
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

open_raw_session_args.__init__ = open_raw_session_args__init__

def open_raw_session_args__setstate__(self, state):
  state.setdefault('device', None)
  state.setdefault('open_timeout', 60)
  state.setdefault('idle_timeout', 300)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

open_raw_session_args.__getstate__ = lambda self: self.__dict__.copy()
open_raw_session_args.__setstate__ = open_raw_session_args__setstate__

class open_raw_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Session()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('open_raw_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(open_raw_session_result)
open_raw_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [Session, Session.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

open_raw_session_result.thrift_struct_annotations = {
}
open_raw_session_result.thrift_field_annotations = {
}

def open_raw_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

open_raw_session_result.__init__ = open_raw_session_result__init__

def open_raw_session_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('se', None)
  self.__dict__ = state

open_raw_session_result.__getstate__ = lambda self: self.__dict__.copy()
open_raw_session_result.__setstate__ = open_raw_session_result__setstate__

class run_raw_session_args:
  """
  Attributes:
   - session
   - command
   - timeout
   - prompt_regex
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.command = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.timeout = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.prompt_regex = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_raw_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 2)
      oprot.writeString(self.command.encode('utf-8')) if UTF8STRINGS and not isinstance(self.command, bytes) else oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I32, 3)
      oprot.writeI32(self.timeout)
      oprot.writeFieldEnd()
    if self.prompt_regex != None:
      oprot.writeFieldBegin('prompt_regex', TType.STRING, 4)
      oprot.writeString(self.prompt_regex.encode('utf-8')) if UTF8STRINGS and not isinstance(self.prompt_regex, bytes) else oprot.writeString(self.prompt_regex)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    if self.command is not None:
      value = pprint.pformat(self.command, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    command=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.prompt_regex is not None:
      value = pprint.pformat(self.prompt_regex, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prompt_regex=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_raw_session_args)
run_raw_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'command', True, None, 2, ), # 2
  (3, TType.I32, 'timeout', None, 300, 2, ), # 3
  (4, TType.STRING, 'prompt_regex', True, None, 2, ), # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

run_raw_session_args.thrift_struct_annotations = {
}
run_raw_session_args.thrift_field_annotations = {
}

def run_raw_session_args__init__(self, session=None, command=None, timeout=run_raw_session_args.thrift_spec[3][4], prompt_regex=None, client_ip=run_raw_session_args.thrift_spec[10][4], client_port=run_raw_session_args.thrift_spec[11][4], uuid=run_raw_session_args.thrift_spec[12][4],):
  self.session = session
  self.command = command
  self.timeout = timeout
  self.prompt_regex = prompt_regex
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

run_raw_session_args.__init__ = run_raw_session_args__init__

def run_raw_session_args__setstate__(self, state):
  state.setdefault('session', None)
  state.setdefault('command', None)
  state.setdefault('timeout', 300)
  state.setdefault('prompt_regex', None)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

run_raw_session_args.__getstate__ = lambda self: self.__dict__.copy()
run_raw_session_args.__setstate__ = run_raw_session_args__setstate__

class run_raw_session_result:
  """
  Attributes:
   - success
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CommandResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('run_raw_session_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(run_raw_session_result)
run_raw_session_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [CommandResult, CommandResult.thrift_spec, False], None, 2, ), # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

run_raw_session_result.thrift_struct_annotations = {
}
run_raw_session_result.thrift_field_annotations = {
}

def run_raw_session_result__init__(self, success=None, se=None,):
  self.success = success
  self.se = se

run_raw_session_result.__init__ = run_raw_session_result__init__

def run_raw_session_result__setstate__(self, state):
  state.setdefault('success', None)
  state.setdefault('se', None)
  self.__dict__ = state

run_raw_session_result.__getstate__ = lambda self: self.__dict__.copy()
run_raw_session_result.__setstate__ = run_raw_session_result__setstate__

class close_raw_session_args:
  """
  Attributes:
   - session
   - client_ip
   - client_port
   - uuid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.client_port = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_raw_session_args')
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 1)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 10)
      oprot.writeString(self.client_ip.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_ip, bytes) else oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.client_port != None:
      oprot.writeFieldBegin('client_port', TType.STRING, 11)
      oprot.writeString(self.client_port.encode('utf-8')) if UTF8STRINGS and not isinstance(self.client_port, bytes) else oprot.writeString(self.client_port)
      oprot.writeFieldEnd()
    if self.uuid != None:
      oprot.writeFieldBegin('uuid', TType.STRING, 12)
      oprot.writeString(self.uuid.encode('utf-8')) if UTF8STRINGS and not isinstance(self.uuid, bytes) else oprot.writeString(self.uuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.client_port is not None:
      value = pprint.pformat(self.client_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_port=%s' % (value))
    if self.uuid is not None:
      value = pprint.pformat(self.uuid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    uuid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_raw_session_args)
close_raw_session_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 1
  None, # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  None, # 9
  (10, TType.STRING, 'client_ip', True, "", 2, ), # 10
  (11, TType.STRING, 'client_port', True, "", 2, ), # 11
  (12, TType.STRING, 'uuid', True, "", 2, ), # 12
)

close_raw_session_args.thrift_struct_annotations = {
}
close_raw_session_args.thrift_field_annotations = {
}

def close_raw_session_args__init__(self, session=None, client_ip=close_raw_session_args.thrift_spec[10][4], client_port=close_raw_session_args.thrift_spec[11][4], uuid=close_raw_session_args.thrift_spec[12][4],):
  self.session = session
  self.client_ip = client_ip
  self.client_port = client_port
  self.uuid = uuid

close_raw_session_args.__init__ = close_raw_session_args__init__

def close_raw_session_args__setstate__(self, state):
  state.setdefault('session', None)
  state.setdefault('client_ip', "")
  state.setdefault('client_port', "")
  state.setdefault('uuid', "")
  self.__dict__ = state

close_raw_session_args.__getstate__ = lambda self: self.__dict__.copy()
close_raw_session_args.__setstate__ = close_raw_session_args__setstate__

class close_raw_session_result:
  """
  Attributes:
   - se
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.se = SessionException()
          self.se.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('close_raw_session_result')
    if self.se != None:
      oprot.writeFieldBegin('se', TType.STRUCT, 1)
      self.se.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.se is not None:
      value = pprint.pformat(self.se, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    se=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(close_raw_session_result)
close_raw_session_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'se', [SessionException, SessionException.thrift_spec, False], None, 2, ), # 1
)

close_raw_session_result.thrift_struct_annotations = {
}
close_raw_session_result.thrift_field_annotations = {
}

def close_raw_session_result__init__(self, se=None,):
  self.se = se

close_raw_session_result.__init__ = close_raw_session_result__init__

def close_raw_session_result__setstate__(self, state):
  state.setdefault('se', None)
  self.__dict__ = state

close_raw_session_result.__getstate__ = lambda self: self.__dict__.copy()
close_raw_session_result.__setstate__ = close_raw_session_result__setstate__

class Client(fb303_asyncio.fb303.FacebookService.Client, Iface):
  def __init__(self, oprot, loop=None):
    fb303_asyncio.fb303.FacebookService.Client.__init__(self, oprot, loop)

  def run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - command
     - device
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_run(command, device, timeout, open_timeout, client_ip, client_port, uuid)
    return fut

  def send_run(self, command=None, device=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('run', TMessageType.CALL, self._seqid)
    args = run_args()
    args.command = command
    args.device = device
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = run_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    if result.ude != None:
      fut.set_exception(result.ude)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result"))
    return

  def bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_bulk_run(device_to_commands, timeout, open_timeout, client_ip, client_port, uuid)
    return fut

  def send_bulk_run(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('bulk_run', TMessageType.CALL, self._seqid)
    args = bulk_run_args()
    args.device_to_commands = device_to_commands
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bulk_run(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = bulk_run_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "bulk_run failed: unknown result"))
    return

  def bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device_to_commands
     - timeout
     - open_timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_bulk_run_local(device_to_commands, timeout, open_timeout, client_ip, client_port, uuid)
    return fut

  def send_bulk_run_local(self, device_to_commands=None, timeout=300, open_timeout=30, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('bulk_run_local', TMessageType.CALL, self._seqid)
    args = bulk_run_local_args()
    args.device_to_commands = device_to_commands
    args.timeout = timeout
    args.open_timeout = open_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bulk_run_local(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = bulk_run_local_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.ioe != None:
      fut.set_exception(result.ioe)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "bulk_run_local failed: unknown result"))
    return

  def open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_open_session(device, open_timeout, idle_timeout, client_ip, client_port, uuid)
    return fut

  def send_open_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('open_session', TMessageType.CALL, self._seqid)
    args = open_session_args()
    args.device = device
    args.open_timeout = open_timeout
    args.idle_timeout = idle_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = open_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "open_session failed: unknown result"))
    return

  def run_session(self, session=None, command=None, timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_run_session(session, command, timeout, client_ip, client_port, uuid)
    return fut

  def send_run_session(self, session=None, command=None, timeout=300, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('run_session', TMessageType.CALL, self._seqid)
    args = run_session_args()
    args.session = session
    args.command = command
    args.timeout = timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = run_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "run_session failed: unknown result"))
    return

  def close_session(self, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_close_session(session, client_ip, client_port, uuid)
    return fut

  def send_close_session(self, session=None, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('close_session', TMessageType.CALL, self._seqid)
    args = close_session_args()
    args.session = session
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_close_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = close_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_result(None)
    return

  def open_raw_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - device
     - open_timeout
     - idle_timeout
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_open_raw_session(device, open_timeout, idle_timeout, client_ip, client_port, uuid)
    return fut

  def send_open_raw_session(self, device=None, open_timeout=60, idle_timeout=300, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('open_raw_session', TMessageType.CALL, self._seqid)
    args = open_raw_session_args()
    args.device = device
    args.open_timeout = open_timeout
    args.idle_timeout = idle_timeout
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_open_raw_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = open_raw_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "open_raw_session failed: unknown result"))
    return

  def run_raw_session(self, session=None, command=None, timeout=300, prompt_regex=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - command
     - timeout
     - prompt_regex
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_run_raw_session(session, command, timeout, prompt_regex, client_ip, client_port, uuid)
    return fut

  def send_run_raw_session(self, session=None, command=None, timeout=300, prompt_regex=None, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('run_raw_session', TMessageType.CALL, self._seqid)
    args = run_raw_session_args()
    args.session = session
    args.command = command
    args.timeout = timeout
    args.prompt_regex = prompt_regex
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_run_raw_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = run_raw_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "run_raw_session failed: unknown result"))
    return

  def close_raw_session(self, session=None, client_ip="", client_port="", uuid=""):
    """
    Parameters:
     - session
     - client_ip
     - client_port
     - uuid
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_close_raw_session(session, client_ip, client_port, uuid)
    return fut

  def send_close_raw_session(self, session=None, client_ip="", client_port="", uuid=""):
    self._oprot.writeMessageBegin('close_raw_session', TMessageType.CALL, self._seqid)
    args = close_raw_session_args()
    args.session = session
    args.client_ip = client_ip
    args.client_port = client_port
    args.uuid = uuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_close_raw_session(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = close_raw_session_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.se != None:
      fut.set_exception(result.se)
      return
    fut.set_result(None)
    return


class Processor(fb303_asyncio.fb303.FacebookService.Processor, Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler, loop=None):
    fb303_asyncio.fb303.FacebookService.Processor.__init__(self, handler, loop)
    self._processMap["run"] = Processor.process_run
    self._priorityMap["run"] = TPriority.NORMAL
    self._processMap["bulk_run"] = Processor.process_bulk_run
    self._priorityMap["bulk_run"] = TPriority.NORMAL
    self._processMap["bulk_run_local"] = Processor.process_bulk_run_local
    self._priorityMap["bulk_run_local"] = TPriority.NORMAL
    self._processMap["open_session"] = Processor.process_open_session
    self._priorityMap["open_session"] = TPriority.NORMAL
    self._processMap["run_session"] = Processor.process_run_session
    self._priorityMap["run_session"] = TPriority.NORMAL
    self._processMap["close_session"] = Processor.process_close_session
    self._priorityMap["close_session"] = TPriority.NORMAL
    self._processMap["open_raw_session"] = Processor.process_open_raw_session
    self._priorityMap["open_raw_session"] = TPriority.NORMAL
    self._processMap["run_raw_session"] = Processor.process_run_raw_session
    self._priorityMap["run_raw_session"] = TPriority.NORMAL
    self._processMap["close_raw_session"] = Processor.process_close_raw_session
    self._priorityMap["close_raw_session"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(fb303_asyncio.fb303.FacebookService.Processor.onewayMethods(self))
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(run_args, oneway=False, asyncio=True)
  def process_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_result()
    if should_run_on_thread(self._handler.run):
      fut = self._loop.run_in_executor(None, self._handler.run, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run, self._loop, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException, 'ude': UnsupportedDeviceException}, f))
    return fut

  @process_method(bulk_run_args, oneway=False, asyncio=True)
  def process_bulk_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_result()
    if should_run_on_thread(self._handler.bulk_run):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.bulk_run, self._loop, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(bulk_run_local_args, oneway=False, asyncio=True)
  def process_bulk_run_local(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_local_result()
    if should_run_on_thread(self._handler.bulk_run_local):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run_local, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.bulk_run_local, self._loop, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'ioe': InstanceOverloaded}, f))
    return fut

  @process_method(open_session_args, oneway=False, asyncio=True)
  def process_open_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_session_result()
    if should_run_on_thread(self._handler.open_session):
      fut = self._loop.run_in_executor(None, self._handler.open_session, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.open_session, self._loop, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_session_args, oneway=False, asyncio=True)
  def process_run_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_session_result()
    if should_run_on_thread(self._handler.run_session):
      fut = self._loop.run_in_executor(None, self._handler.run_session, args.session, args.command, args.timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run_session, self._loop, args.session, args.command, args.timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_session_args, oneway=False, asyncio=True)
  def process_close_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_session_result()
    if should_run_on_thread(self._handler.close_session):
      fut = self._loop.run_in_executor(None, self._handler.close_session, args.session, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.close_session, self._loop, args.session, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(open_raw_session_args, oneway=False, asyncio=True)
  def process_open_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_raw_session_result()
    if should_run_on_thread(self._handler.open_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.open_raw_session, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.open_raw_session, self._loop, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_raw_session_args, oneway=False, asyncio=True)
  def process_run_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_raw_session_result()
    if should_run_on_thread(self._handler.run_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.run_raw_session, args.session, args.command, args.timeout, args.prompt_regex, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run_raw_session, self._loop, args.session, args.command, args.timeout, args.prompt_regex, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_raw_session_args, oneway=False, asyncio=True)
  def process_close_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_raw_session_result()
    if should_run_on_thread(self._handler.close_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.close_raw_session, args.session, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.close_raw_session, self._loop, args.session, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

Iface._processor_type = Processor

class ContextProcessor(fb303_asyncio.fb303.FacebookService.ContextProcessor, ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler, loop=None):
    fb303_asyncio.fb303.FacebookService.ContextProcessor.__init__(self, handler, loop)
    self._processMap["run"] = ContextProcessor.process_run
    self._priorityMap["run"] = TPriority.NORMAL
    self._processMap["bulk_run"] = ContextProcessor.process_bulk_run
    self._priorityMap["bulk_run"] = TPriority.NORMAL
    self._processMap["bulk_run_local"] = ContextProcessor.process_bulk_run_local
    self._priorityMap["bulk_run_local"] = TPriority.NORMAL
    self._processMap["open_session"] = ContextProcessor.process_open_session
    self._priorityMap["open_session"] = TPriority.NORMAL
    self._processMap["run_session"] = ContextProcessor.process_run_session
    self._priorityMap["run_session"] = TPriority.NORMAL
    self._processMap["close_session"] = ContextProcessor.process_close_session
    self._priorityMap["close_session"] = TPriority.NORMAL
    self._processMap["open_raw_session"] = ContextProcessor.process_open_raw_session
    self._priorityMap["open_raw_session"] = TPriority.NORMAL
    self._processMap["run_raw_session"] = ContextProcessor.process_run_raw_session
    self._priorityMap["run_raw_session"] = TPriority.NORMAL
    self._processMap["close_raw_session"] = ContextProcessor.process_close_raw_session
    self._priorityMap["close_raw_session"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(fb303_asyncio.fb303.FacebookService.ContextProcessor.onewayMethods(self))
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(run_args, oneway=False, asyncio=True)
  def process_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_result()
    if should_run_on_thread(self._handler.run):
      fut = self._loop.run_in_executor(None, self._handler.run, handler_ctx, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run, self._loop, handler_ctx, args.command, args.device, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException, 'ude': UnsupportedDeviceException}, f))
    return fut

  @process_method(bulk_run_args, oneway=False, asyncio=True)
  def process_bulk_run(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_result()
    if should_run_on_thread(self._handler.bulk_run):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.bulk_run, self._loop, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(bulk_run_local_args, oneway=False, asyncio=True)
  def process_bulk_run_local(self, args, handler_ctx, seqid, oprot, fn_name):
    result = bulk_run_local_result()
    if should_run_on_thread(self._handler.bulk_run_local):
      fut = self._loop.run_in_executor(None, self._handler.bulk_run_local, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.bulk_run_local, self._loop, handler_ctx, args.device_to_commands, args.timeout, args.open_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'ioe': InstanceOverloaded}, f))
    return fut

  @process_method(open_session_args, oneway=False, asyncio=True)
  def process_open_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_session_result()
    if should_run_on_thread(self._handler.open_session):
      fut = self._loop.run_in_executor(None, self._handler.open_session, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.open_session, self._loop, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_session_args, oneway=False, asyncio=True)
  def process_run_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_session_result()
    if should_run_on_thread(self._handler.run_session):
      fut = self._loop.run_in_executor(None, self._handler.run_session, handler_ctx, args.session, args.command, args.timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run_session, self._loop, handler_ctx, args.session, args.command, args.timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_session_args, oneway=False, asyncio=True)
  def process_close_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_session_result()
    if should_run_on_thread(self._handler.close_session):
      fut = self._loop.run_in_executor(None, self._handler.close_session, handler_ctx, args.session, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.close_session, self._loop, handler_ctx, args.session, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(open_raw_session_args, oneway=False, asyncio=True)
  def process_open_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = open_raw_session_result()
    if should_run_on_thread(self._handler.open_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.open_raw_session, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.open_raw_session, self._loop, handler_ctx, args.device, args.open_timeout, args.idle_timeout, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(run_raw_session_args, oneway=False, asyncio=True)
  def process_run_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = run_raw_session_result()
    if should_run_on_thread(self._handler.run_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.run_raw_session, handler_ctx, args.session, args.command, args.timeout, args.prompt_regex, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.run_raw_session, self._loop, handler_ctx, args.session, args.command, args.timeout, args.prompt_regex, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

  @process_method(close_raw_session_args, oneway=False, asyncio=True)
  def process_close_raw_session(self, args, handler_ctx, seqid, oprot, fn_name):
    result = close_raw_session_result()
    if should_run_on_thread(self._handler.close_raw_session):
      fut = self._loop.run_in_executor(None, self._handler.close_raw_session, handler_ctx, args.session, args.client_ip, args.client_port, args.uuid)
    else:
      fut = call_as_future(self._handler.close_raw_session, self._loop, handler_ctx, args.session, args.client_ip, args.client_port, args.uuid)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {'se': SessionException}, f))
    return fut

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

